#!/usr/bin/env sh
# COPYRIGHT


set -e
set -f
set -u

program_name="alpine-linux-enter-chroot"

_program_path_find()
{
	if [ "${0%/*}" = "$0" ]; then

		# We've been invoked by the interpreter as, say, bash program
		if [ -r "$0" ]; then
			pwd -P
		# Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
		else
			printf '\n'
		fi

	else

		# We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

		_program_path_find_parentPath()
		{
			parentPath="${scriptPath%/*}"
			if [ -z "$parentPath" ]; then
				parentPath='/'
			fi
			cd "$parentPath" 1>/dev/null
		}

		# pdksh / mksh have problems with unsetting a variable that was never set...
		if [ "${CDPATH+set}" = 'set' ]; then
			unset CDPATH
		fi

		if command -v realpath 1>/dev/null 2>/dev/null; then
			(
				scriptPath="$(realpath "$0")"

				_program_path_find_parentPath
				pwd -P
			)
		elif command -v readlink 1>/dev/null 2>/dev/null; then
			(
				local recursionDepth=0
				_program_path_resolve_symlinks_recursively()
				{
					local unresolvedPath="$1"
					
					recursionDepth=$((recursionDepth + 1))
					
					if [ $recursionDepth -gt 10 ]; then
						printf '%s\n' 'Recursion to depths greater than 10 is not allowed when resolving links.'
						return 1
					fi
					
					local potentialLinkDestination="$(readlink -- "$unresolvedPath")"
					
					if [ -z "$potentialLinkDestination" ]; then
						scriptPath="$unresolvedPath"
						return 0
					fi
					local linkDestination="$potentialLinkDestination"
					local parentFolderPath="${unresolvedPath%/*}"
					
					if [ "$parentFolderPath" = "$unresolvedPath" ]; then
						_program_path_resolve_symlinks_recursively "$linkDestination"
					else
						case "$linkDestination" in
														
							/*)
								_program_path_resolve_symlinks_recursively "$linkDestination"
							;;
							
							*)
								_program_path_resolve_symlinks_recursively "$parentFolderPath"/"$linkDestination"
							;;
							
						esac
					fi
				}

				scriptPath="$0"
				_program_path_resolve_symlinks_recursively "$scriptPath"

				_program_path_find_parentPath
				pwd -P
			)
		else
			# This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
			(
				scriptPath="$0"

				_program_path_find_parentPath
				pwd -P
			)
		fi

	fi
}

fail()
{
	local exitCode="$1"
	local message="$2"
	
	printf '%s:FAIL:%s\n' "$program_name" "$message" 1>&2
	exit $exitCode
}

depends()
{
	local binary
	for binary in "$@"
	do
		if ! command -v "$binary" 1>/dev/null 2>/dev/null; then
			printf '%s:%s\n' "$program_name" "The binary `$binary` is not on the PATH" 1>&2
			local EX_OSFILE=72
			exit $EX_OSFILE
		fi
	done
}

depends cp rm mkdir
alpine_linux_enter_chroot_createChroot()
{
	cp -a "$alpine_linux_extractFolderPath"/. "$alpine_linux_chrootFolderPath"/
	set +f
		rm -rf "$alpine_linux_chrootFolderPath"/.alpine-linux.*
	set -f

	# Create basic folders.
	local folder
	for folder in dev etc home mnt opt proc root run sys tmp usr/local usr/local/bin usr/local/sbin var var/cache var/run var/tmp
	do
		mkdir -m 0700 -p "$alpine_linux_chrootFolderPath"/"$folder"
	done
}

depends env chroot
alpine_linux_enter_chroot_mountRunAndUnmount()
{
	cd "$alpine_linux_chrootFolderPath" 1>/dev/null 2>/dev/null

		trap "" EXIT HUP INT QUIT TERM

			environment_mountPseudoFileSystem proc "$alpine_linux_chrootFolderPath"/proc
			environment_recursivelyMount /sys "$alpine_linux_chrootFolderPath"/sys
			environment_recursivelyMount /dev "$alpine_linux_chrootFolderPath"/dev

			shift $alpine_linux_positionalArgumentsStartAt
			set +e
				env -i PATH='/usr/sbin:/sbin:/usr/bin:/bin' LOGNAME='root' USER='root' HOME='/root' LANG=C.UTF-8 LANGUAGE=en_US:en chroot . "$@"
				local exitCode=$?
			set -e

			environment_recursivelyUnmountInChroot "$alpine_linux_chrootFolderPath"/dev
			environment_recursivelyUnmountInChroot "$alpine_linux_chrootFolderPath"/sys
			environment_recursivelyUnmountInChroot "$alpine_linux_chrootFolderPath"/proc

			if [ $exitCode -ne 0 ]; then
				exit $exitCode
			fi

		trap - EXIT HUP INT QUIT TERM

	cd - 1>/dev/null 2>/dev/null
}

alpine_linux_enter_chroot()
{
	cd "$(_program_path_find)" 1>/dev/null 2>/dev/null

	. "$(pwd)"/alpine-linux.functions.sh

	local environment_parseCommandLineArguments_message="${program_name}:  Enters an Alpine Linux chroot.

Usage: ${program_name} -h | --help
Usage: ${program_name} [-c|--configuration /path/to/configuration/folder] [-o|--output /path/to/output/folder]

If the configuration folder path is not provided, it defaults to program_location/sample-configuration.

If the output folder path is not provided, it defaults to program_location/output. The output folder path is created as necessary.
"
	_additionalArgumentsCallback()
	{
			environment_parseCommandLineArguments_errorHelp "Unexpected argument '$key'"
	}
	_positionalArgumentsCallback()
	{
		if [ $# -eq 0 ]; then
			environment_parseCommandLineArguments_errorHelp "At least one positional argument should be specified (an absolute path to a binary to run in the chroot)"
		fi
	}
	local alpine_linux_positionalArgumentsStartAt
	local alpine_linux_configurationFolderPath="$(pwd)"/sample-configuration
	local alpine_linux_outputFolderPath="$(pwd)"/output
	alpine_linux_parseCommandLineArguments _additionalArgumentsCallback _positionalArgumentsCallback "$@"
	
	alpine_linux_validateCommandLineArguments

	local alpine_linux_temporaryFolderPath
	local alpine_linux_versionFilePath
	local alpine_linux_packagesFilePath
	local alpine_linux_busyboxStaticBinariesFilePath
	local alpine_linux_mirrorFolderPath
	local alpine_linux_mirrorVersionFilePath
	local alpine_linux_indexFolderPath
	local alpine_linux_indexVersionFilePath
	local alpine_linux_packagesFolderPath
	local alpine_linux_packagesVersionFilePath
	local alpine_linux_extractFolderPath
	local alpine_linux_extractVersionFilePath
	local alpine_linux_extractPackagesFilePath
	local alpine_linux_extractBusyboxStaticBinariesFilePath
	local alpine_linux_majorVersion
	local alpine_linux_minorVersion
	local alpine_linux_revisionVersion
	local alpine_linux_apkToolsVersion
	local alpine_linux_versionMirror
	local alpine_linux_releasesMirror
	local alpine_linux_architecture
	alpine_linux_setEnvironmentVariables

	"$(pwd)"/alpine-linux-download --configuration "$alpine_linux_configurationFolderPath" --output "$alpine_linux_outputFolderPath"

	local alpine_linux_chrootFolderPath="$alpine_linux_outputFolderPath"/chroot

	alpine_linux_enter_chroot_createChroot

	environment_reRunAsRootIfRequired

	alpine_linux_enter_chroot_mountRunAndUnmount "$@"
}

alpine_linux_enter_chroot "$@"
