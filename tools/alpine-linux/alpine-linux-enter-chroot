#!/usr/bin/env sh
# COPYRIGHT


set -e
set -f
set -u

program_name="alpine-linux-enter-chroot"

_program_path_find()
{
	if [ "${0%/*}" = "$0" ]; then

		# We've been invoked by the interpreter as, say, bash program
		if [ -r "$0" ]; then
			pwd -P
		# Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
		else
			printf '\n'
		fi

	else

		# We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

		_program_path_find_parentPath()
		{
			parentPath="${scriptPath%/*}"
			if [ -z "$parentPath" ]; then
				parentPath='/'
			fi
			cd "$parentPath" 1>/dev/null
		}

		# pdksh / mksh have problems with unsetting a variable that was never set...
		if [ "${CDPATH+set}" = 'set' ]; then
			unset CDPATH
		fi

		if command -v realpath 1>/dev/null 2>/dev/null; then
			(
				scriptPath="$(realpath "$0")"

				_program_path_find_parentPath
				pwd -P
			)
		elif command -v readlink 1>/dev/null 2>/dev/null; then
			(
				local recursionDepth=0
				_program_path_resolve_symlinks_recursively()
				{
					local unresolvedPath="$1"
					
					recursionDepth=$((recursionDepth + 1))
					
					if [ $recursionDepth -gt 10 ]; then
						printf '%s\n' 'Recursion to depths greater than 10 is not allowed when resolving links.'
						return 1
					fi
					
					local potentialLinkDestination="$(readlink -- "$unresolvedPath")"
					
					if [ -z "$potentialLinkDestination" ]; then
						scriptPath="$unresolvedPath"
						return 0
					fi
					local linkDestination="$potentialLinkDestination"
					local parentFolderPath="${unresolvedPath%/*}"
					
					if [ "$parentFolderPath" = "$unresolvedPath" ]; then
						_program_path_resolve_symlinks_recursively "$linkDestination"
					else
						case "$linkDestination" in
														
							/*)
								_program_path_resolve_symlinks_recursively "$linkDestination"
							;;
							
							*)
								_program_path_resolve_symlinks_recursively "$parentFolderPath"/"$linkDestination"
							;;
							
						esac
					fi
				}

				scriptPath="$0"
				_program_path_resolve_symlinks_recursively "$scriptPath"

				_program_path_find_parentPath
				pwd -P
			)
		else
			# This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
			(
				scriptPath="$0"

				_program_path_find_parentPath
				pwd -P
			)
		fi

	fi
}

fail()
{
	local exitCode="$1"
	local message="$2"
	
	printf '%s:FAIL:%s\n' "$program_name" "$message" 1>&2
	exit $exitCode
}

depends()
{
	local binary
	for binary in "$@"
	do
		if ! command -v "$binary" 1>/dev/null 2>/dev/null; then
			printf '%s:%s\n' "$program_name" "The binary `$binary` is not on the PATH" 1>&2
			local EX_OSFILE=72
			exit $EX_OSFILE
		fi
	done
}

depends cp rm
alpine_linux_enter_chroot_createChroot_copyExtract()
{
	cp -a "$alpine_linux_extractFolderPath"/. "$alpine_linux_chrootFolderPath"/
	set +f
		rm -rf "$alpine_linux_chrootFolderPath"/.alpine-linux.*
	set -f
}

depends mkdir
alpine_linux_enter_chroot_createChroot_makeCoreFolders()
{
	local folder
	for folder in dev etc home mnt opt proc root run sys tmp usr/local usr/local/bin usr/local/sbin var/cache var/run var/tmp
	do
		mkdir -m 0700 -p "$alpine_linux_chrootFolderPath"/"$folder"
	done
}

depends id mkdir
alpine_linux_enter_chroot_createChroot_createBarebonesEtcPasswd()
{
	local currentUid="$(id -u)"
	local currentGid="$(id -g)"

	{
		_alpine_linux_enter_chroot_createChroot_createBarebonesEtcPasswd_entry()
		{
			local user="$1"
			local uid="$2"
			local gid="$3"
			local homeFolderPath="$4"
			local shellFilePath="$5"
			local gecos="$user"
			printf '%s:x:%s:%s:%s:%s:%s\n' "$user" "$uid" "$gid" "$gecos" "$homeFolderPath" "$shellFilePath"
		}

		_alpine_linux_enter_chroot_createChroot_createBarebonesEtcPasswd_entry root 0 0 /root /bin/sh

		if [ $currentUid -ne 0 ]; then
			if [ $currentGid -ne 0 ]; then
				local user='currentuser'
				_alpine_linux_enter_chroot_createChroot_createBarebonesEtcPasswd_entry "$user" "$currentUid" "$currentGid" /home/"$user" /bin/sh
				mkdir -m 0700 -p "$alpine_linux_chrootFolderPath"/home/"$user"
			fi
		fi

	} >"$alpine_linux_chrootFolderPath"/etc/passwd
}

depends cp rm mkdir
alpine_linux_enter_chroot_createChroot()
{
	alpine_linux_enter_chroot_createChroot_copyExtract

	alpine_linux_enter_chroot_createChroot_makeCoreFolders

	alpine_linux_enter_chroot_createChroot_createBarebonesEtcPasswd
}

depends cat chmod
alpine_linux_enter_chroot_createSuCommandToRunAsCurrentUser()
{
	shift $alpine_linux_positionalArgumentsStartAt
	{
		cat <<-EOF
			#!/bin/sh

			set -e
			set -f
			set -u

		EOF

		printf 'exec'

		local argument
		for argument in "$@"
		do
			local escapedArgument="$(printf '%s' "$argument" | sed -e s/\'/\'\"\'\"\'/g)"
			printf " '%s'" "$escapedArgument"
		done
		printf '\n'

	} >"$alpine_linux_chrootFolderPath"/su-command
	chmod 0700 "$alpine_linux_chrootFolderPath"/su-command
}

depends env chroot
alpine_linux_enter_chroot_run()
{
	set -- \
		PATH='/usr/sbin:/sbin:/usr/bin:/bin' \
		LOGNAME='currentuser' \
		USER='currentuser' \
		HOME='/home/currentuser' \
		LANG=C.UTF-8 \
		LANGUAGE=en_US:en \
		chroot . \
			/bin/su \
			-p \
			-s /bin/sh \
			-c 'exec /su-command' \
			currentuser
	if [ -t 1 ]; then
		set -- TERM="${TERM:-dumb}" "$@"
	fi

	set +e
		env -i "$@"
		exitCode=$?
	set -e
}

alpine_linux_enter_chroot_mountRunAndUnmount()
{
	_alpine_linux_enter_chroot_mountRunAndUnmount_cleanUp()
	{
		environment_recursivelyUnmountInChroot "$alpine_linux_chrootFolderPath"
	}

	cd "$alpine_linux_chrootFolderPath" 1>/dev/null 2>/dev/null

		trap _alpine_linux_enter_chroot_mountRunAndUnmount_cleanUp EXIT HUP INT QUIT TERM

			local mountFromFolderPath
			local mountToFolderPath
			local recursiveMount
			while IFS=':' read -r mountFromFolderPath mountToFolderPath recursiveMount
			do
				case "$recursiveMount" in

					true| false)
						:
					;;

					'')
						continue
					;;

					*)
						fail 1 "Invalid mount data"
					;;

				esac

				environment_bindMount "$mountFromFolderPath" "${alpine_linux_chrootFolderPath}${mountToFolderPath}" "$recursiveMount"
			done <<-EOF
				${alpine_linux_mount}
			EOF

			environment_mountPseudoFileSystem proc "$alpine_linux_chrootFolderPath"/proc
			environment_recursivelyMount /sys "$alpine_linux_chrootFolderPath"/sys
			environment_recursivelyMount /dev "$alpine_linux_chrootFolderPath"/dev

			local exitCode
			alpine_linux_enter_chroot_run "$@"

			_alpine_linux_enter_chroot_mountRunAndUnmount_cleanUp

		trap - EXIT HUP INT QUIT TERM

		if [ $exitCode -ne 0 ]; then
			exit $exitCode
		fi

	cd - 1>/dev/null 2>/dev/null
}

alpine_linux_enter_chroot_main()
{
	cd "$(_program_path_find)" 1>/dev/null 2>/dev/null

	. "$(pwd)"/alpine-linux.functions.sh

	local environment_parseCommandLineArguments_message="${program_name}:  Enters an Alpine Linux chroot.

Usage: ${program_name} -h | --help
Usage: ${program_name} [-c|--configuration /path/to/configuration/folder] [-o|--output /path/to/output/folder [-m|--mount from1:to1:recursive1,from2:to2:recursive2]]

If the configuration folder path is not provided, it defaults to program_location/sample-configuration.

If the output folder path is not provided, it defaults to program_location/output. The output folder path is created as necessary.

The mount argument is a triplet of from folder path and to folder path and true/false for recursive mounting. It can be repeated.
from folder path and to folder path should not contain colons or new lines.
"
	local alpine_linux_mount=""
	_additionalArgumentsCallback()
	{
		case "$key" in
			-m|--mount)
				environment_parseCommandLineArguments_missingArgument "$@"
				alpine_linux_mount="${alpine_linux_mount}
${value}"
				_additionalArgumentsCallback_shiftUp=1
			;;

			--mount=*)
				value="${key##--mount=}"
				alpine_linux_mount="${alpine_linux_mount}
${value}"
			;;

			-m*)
				environment_parseCommandLineArguments_alreadyParsed $alpine_linux_configurationFolderPathParsed
				value="${key##-m}"
				alpine_linux_mount="${alpine_linux_mount}
${value}"
			;;

			*)
				environment_parseCommandLineArguments_errorHelp "Unexpected argument '$key'"
			;;
		esac
	}
	_positionalArgumentsCallback()
	{
		if [ $# -eq 0 ]; then
			environment_parseCommandLineArguments_errorHelp "At least one positional argument should be specified (an absolute path to a binary to run in the chroot)"
		fi
	}
	local alpine_linux_positionalArgumentsStartAt
	local alpine_linux_configurationFolderPath="$(pwd)"/sample-configuration
	local alpine_linux_outputFolderPath="$(pwd)"/output
	alpine_linux_parseCommandLineArguments _additionalArgumentsCallback _positionalArgumentsCallback "$@"
	
	alpine_linux_validateCommandLineArguments

	local alpine_linux_temporaryFolderPath
	local alpine_linux_versionFilePath
	local alpine_linux_packagesFilePath
	local alpine_linux_busyboxStaticBinariesFilePath
	local alpine_linux_mirrorFolderPath
	local alpine_linux_mirrorVersionFilePath
	local alpine_linux_indexFolderPath
	local alpine_linux_indexVersionFilePath
	local alpine_linux_packagesFolderPath
	local alpine_linux_packagesVersionFilePath
	local alpine_linux_extractFolderPath
	local alpine_linux_extractVersionFilePath
	local alpine_linux_extractPackagesFilePath
	local alpine_linux_extractBusyboxStaticBinariesFilePath
	local alpine_linux_majorVersion
	local alpine_linux_minorVersion
	local alpine_linux_revisionVersion
	local alpine_linux_apkToolsVersion
	local alpine_linux_versionMirror
	local alpine_linux_releasesMirror
	local alpine_linux_architecture
	alpine_linux_setEnvironmentVariables

	"$(pwd)"/alpine-linux-download --configuration "$alpine_linux_configurationFolderPath" --output "$alpine_linux_outputFolderPath"

	local alpine_linux_chrootFolderPath="$alpine_linux_outputFolderPath"/chroot

	local reRunAsRoot=true

	if [ -n "${SUDO_UID+isset}" ]; then
		reRunAsRoot=false
	fi
	
	if $reRunAsRoot; then
		alpine_linux_enter_chroot_createChroot
		alpine_linux_enter_chroot_createSuCommandToRunAsCurrentUser "$@"
		environment_reRunAsRootIfRequired "$@"
	fi

	alpine_linux_enter_chroot_mountRunAndUnmount
}

alpine_linux_enter_chroot_main "$@"
