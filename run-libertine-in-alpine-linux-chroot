#!/usr/bin/env sh

set -e
set -f
set -u

program_name="run-libertine-in-alpine-linux-chroot"

_program_path_find()
{
	if [ "${0%/*}" = "$0" ]; then

		# We've been invoked by the interpreter as, say, bash program
		if [ -r "$0" ]; then
			pwd -P
		# Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
		else
			printf '\n'
		fi

	else

		# We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

		_program_path_find_parentPath()
		{
			parentPath="${scriptPath%/*}"
			if [ -z "$parentPath" ]; then
				parentPath='/'
			fi
			cd "$parentPath" 1>/dev/null
		}

		# pdksh / mksh have problems with unsetting a variable that was never set...
		if [ "${CDPATH+set}" = 'set' ]; then
			unset CDPATH
		fi

		if command -v realpath 1>/dev/null 2>/dev/null; then
			(
				scriptPath="$(realpath "$0")"

				_program_path_find_parentPath
				pwd -P
			)
		elif command -v readlink 1>/dev/null 2>/dev/null; then
			(
				local recursionDepth=0
				_program_path_resolve_symlinks_recursively()
				{
					local unresolvedPath="$1"
					
					recursionDepth=$((recursionDepth + 1))
					
					if [ $recursionDepth -gt 10 ]; then
						printf '%s\n' 'Recursion to depths greater than 10 is not allowed when resolving links.'
						return 1
					fi
					
					local potentialLinkDestination="$(readlink -- "$unresolvedPath")"
					
					if [ -z "$potentialLinkDestination" ]; then
						scriptPath="$unresolvedPath"
						return 0
					fi
					local linkDestination="$potentialLinkDestination"
					local parentFolderPath="${unresolvedPath%/*}"
					
					if [ "$parentFolderPath" = "$unresolvedPath" ]; then
						_program_path_resolve_symlinks_recursively "$linkDestination"
					else
						case "$linkDestination" in
														
							/*)
								_program_path_resolve_symlinks_recursively "$linkDestination"
							;;
							
							*)
								_program_path_resolve_symlinks_recursively "$parentFolderPath"/"$linkDestination"
							;;
							
						esac
					fi
				}

				scriptPath="$0"
				_program_path_resolve_symlinks_recursively "$scriptPath"

				_program_path_find_parentPath
				pwd -P
			)
		else
			# This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
			(
				scriptPath="$0"

				_program_path_find_parentPath
				pwd -P
			)
		fi

	fi
}

fail()
{
	local message="$1"
	
	printf '%s:FAIL:%s\n' "$program_name" "$message" 1>&2
	exit 1
}

depends()
{
	local binary
	for binary in "$@"
	do
		if ! command -v "$binary" 1>/dev/null 2>/dev/null; then
			printf '%s:%s\n' "$program_name" "The binary `$binary` is not on the PATH"
			local EX_OSFILE=72
			exit $EX_OSFILE
		fi
	done
}

run_libertine_in_alpine_linux_chroot_main_parseCommandLineArguments()
{
	# Parse non-positional arguments.
	local key
	local value
	while [ $# -gt 0 ]
	do
		local key="$1"

		case "$key" in

			--)
				run_libertine_in_alpine_linux_chroot_positionalArgumentsStartAt=$((run_libertine_in_alpine_linux_chroot_positionalArgumentsStartAt + 1))
				shift 1
				break
			;;

			-h|--help|-h*)
				local EXIT_SUCCESS=0
				environment_parseCommandLineArguments_printHelp $EXIT_SUCCESS
			;;

			-c|--configuration)
				environment_parseCommandLineArguments_alreadyParsed $alpine_linux_configurationFolderPathParsed
				environment_parseCommandLineArguments_missingArgument "$@"
				alpine_linux_configurationFolderPath="$value"
				alpine_linux_configurationFolderPathParsed=true

				alpine_linux_positionalArgumentsStartAt=$((alpine_linux_positionalArgumentsStartAt + 1))
				shift 1
			;;

			--configuration=*)
				environment_parseCommandLineArguments_alreadyParsed $alpine_linux_configurationFolderPathParsed
				alpine_linux_configurationFolderPath="${key##--configuration=}"
				alpine_linux_configurationFolderPathParsed=true
			;;

			-c*)
				environment_parseCommandLineArguments_alreadyParsed $alpine_linux_configurationFolderPathParsed
				alpine_linux_configurationFolderPath="${key##-c}"
				alpine_linux_configurationFolderPathParsed=true
			;;

			-o|--output)
				environment_parseCommandLineArguments_alreadyParsed $alpine_linux_outputFolderPathParsed
				environment_parseCommandLineArguments_missingArgument "$@"
				alpine_linux_outputFolderPath="$value"
				alpine_linux_outputFolderPathParsed=true

				alpine_linux_positionalArgumentsStartAt=$((alpine_linux_positionalArgumentsStartAt + 1))
				shift 1
			;;

			--output=*)
				environment_parseCommandLineArguments_alreadyParsed $alpine_linux_outputFolderPathParsed
				alpine_linux_outputFolderPath="${key##--output=}"
				alpine_linux_outputFolderPathParsed=true

			;;

			-o*)
				environment_parseCommandLineArguments_alreadyParsed $alpine_linux_outputFolderPathParsed
				alpine_linux_outputFolderPath="${key##-o}"
				alpine_linux_outputFolderPathParsed=true
			;;

			-*)
				local _additionalArgumentsCallback_shiftUp
				$additionalArgumentsCallback "$@"
				if [ $_additionalArgumentsCallback_shiftUp -gt 0 ]; then
					alpine_linux_positionalArgumentsStartAt=$((alpine_linux_positionalArgumentsStartAt + _additionalArgumentsCallback_shiftUp))
					shift $_additionalArgumentsCallback_shiftUp
				fi
			;;

			*)
				break
			;;

		esac

		alpine_linux_positionalArgumentsStartAt=$((alpine_linux_positionalArgumentsStartAt + 1))
		shift 1

	done

	# Parse positional arguments.
	$positionalArgumentsCallback
}

run_libertine_in_alpine_linux_chroot_main()
{
	cd "$(_program_path_find)" 1>/dev/null 2>/dev/null

	. tools/alpine-linux/environment-functions.sh

	local environment_parseCommandLineArguments_message="${program_name} Downloads and caches an Alpine Linux kernel, initramfs and packages for a basic known build environment.

Usage: ${program_name} -h | --help
Usage: ${program_name} [-c|--configuration /path/to/configuration/folder] [-o|--output /path/to/output/folder]

If the configuration folder path is not provided, it defaults to program_location/configuration.

If the output folder path is not provided, it defaults to program_location/output. The output folder path is created as necessary.
"
	local run_libertine_in_alpine_linux_chroot_positionalArgumentsStartAt=0


# TODO: Parse our arguments, if any, then pass positional arguments to libertine after bind-mounting

	run_libertine_in_alpine_linux_chroot_main_parseCommandLineArguments "$@"
}

run_libertine_in_alpine_linux_chroot_main "$@"
