# This file is part of libertine. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT. No part of libertine, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2016 The developers of libertine. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT.


core_usesIn libertine public

core_dependency_requires '*' mkdir cp
_libertine_compile_copySourcePath()
{
	local originalPackagePath="$(libertine_public_originalPackagePath)"
	
	local packagePath="$(libertine_public_packagePath)"
	
	if [ -z "$copy_subset" ]; then
		mkdir -m 0755 -p "$packagePath"
		cp -a -f -H "$originalPackagePath"/. "$packagePath"/
	else
		mkdir -m 0755 -p "$packagePath"
		
		IFS=' ' set -- $copy_subset
		local relativePath
		for relativePath in "$@"
		do
			mkdir -m 0755 -p "$packagePath"/"$relativePath"
			cp -a -f -H "$originalPackagePath"/"$relativePath"/. "$packagePath"/"$relativePath"/
		done
	fi
}

core_dependency_requires '*' cat
_libertine_compile_installMenuConfigIfPresent()
{
	local configFilePath="$(libertine_public_packagePath)"/"$package".mk
	local packageConfigFilePath="$libertine_machinePackageConfigurationsFolderPath"/"$package".mk
	
	if [ -s "$packageConfigFilePath" ]; then
		core_message NOTICE "  ${_libertine_compile_depth}Installing menuconfig (override)"
		cat "$packageConfigFilePath" >"$(libertine_public_sourcePath "$package" "$variant")"/.config
	elif [ -s "$configFilePath" ]; then
		core_message NOTICE "  ${_libertine_compile_depth}Installing menuconfig (default)"
		cat "$configFilePath" >"$(libertine_public_sourcePath "$package" "$variant")"/.config
	fi
}

_libertine_compile_sourcePackageConfig()
{
	local packageConfigFilePath="$libertine_machinePackageConfigurationsFolderPath"/"$package".config
	if [ -f "$packageConfigFilePath" ]; then
		core_message NOTICE "  ${_libertine_compile_depth}Package '$package' sourcing config"
		{
			printf '*** Sourcing package config ***\n'
			printf '*** Sourcing package config ***\n' 1>&2
			. "$packageConfigFilePath"
			printf '*** Done Sourcing package config ***\n\n\n'
			printf '*** Done Sourcing package config ***\n\n\n' 1>&2
		} 1>>"$logFolderPath"/out.log 2>>"$logFolderPath"/err.log
	fi
}

core_dependency_requires '*' cp
_libertine_compile_patchIfPresent()
{
	local patchesFilePath="$(libertine_public_packagePath)"/"$package".patches
	if [ -s "$patchesFilePath" ]; then
				
		core_message NOTICE "  ${_libertine_compile_depth}Patching using '$package.patches'"
		pushd "$(libertine_public_sourcePath)"
		
			{
				printf '*** Patching ***\n'
				printf '*** Patching ***\n' 1>&2
				. "$patchesFilePath" "$variant" "$(libertine_public_packagePath)"/patches
				printf '*** Done Patching ***\n\n\n'
				printf '*** Done Patching ***\n\n\n' 1>&2
			} 1>>"$logFolderPath"/out.log 2>>"$logFolderPath"/err.log
		
		popd
	fi
}

core_usesIn libertine configsite
core_dependency_requires '*' rm mkdir
_libertine_compile_createInputSysroot()
{
	local inputSysrootPath="$(libertine_public_inputSysrootPath)"
		
	# Make folders necessary for pkgconfig
	mkdir -m 0755 -p "$inputSysrootPath"/usr/lib/pkgconfig "$inputSysrootPath"/usr/share/pkgconfig
	
	# Make folders necessary for libtool LT_SYS_LIBRARY_PATH
	mkdir -m 0755 -p "$inputSysrootPath"/usr/lib
		
	libertine_env_resetAfterNewInputSysroot "$inputSysrootPath"
}

_libertine_compile_buildDependency()
{
	local ourPackage="$package"
	local dependentPackage="$core_variable_array_element"

	libertine_compile_buildDependencyIfRequiredAndAddOurselvesToItsListOfReverseDependencies "$ourPackage" "$dependentPackage"
}

_libertine_compile_theLinuxPackageAlsoDependsOnPackagesInThePackagesListFile()
{
	_libertine_compile_theLinuxPackageAlsoDependsOnPackagesInThePackagesListFile_callback()
	{
		local dependentPackage="$core_variable_array_element"
	
		core_variable_array_appendUniquely _libertine_compile_depends "$dependentPackage"
	}
	
	core_variable_array_iterate _libertine_packages _libertine_compile_theLinuxPackageAlsoDependsOnPackagesInThePackagesListFile_callback
}

core_dependency_requires '*' rm
libertine_compile_packageLock_addLockTrapHandler()
{
	_libertine_compile_packageLock_addLockTrapHandler_callback()
	{
		if [ -n "$_libertine_compile_packageLock_addLockTrapHandler_package" ]; then
			pushd "$libertine_packageLocksOutputFolderPath"
	
				rm -rf "$_libertine_compile_packageLock_addLockTrapHandler_package"
	
			popd
		fi
	}

	_libertine_compile_packageLock_addLockTrapHandler_package=''
	core_trap_addOnCleanUp _libertine_compile_packageLock_addLockTrapHandler_callback
}

core_dependency_requires '*' mkdir sleep
_libertine_compile_packageLock_acquirePerPackageMutexLock()
{
	local package="$1"
	
	core_trap_addOnCleanUp _libertine_compile_packageLock_releasePerPackageMutexLock
	
	# If SIGTERM happens after mkdir but before assignment of the $package value to _libertine_compile_packageLock_addLockTrapHandler_package, then the lock folder may be left locked
	pushd "$libertine_packageLocksOutputFolderPath"
		
		# Spinlock
		while true
		do
			if mkdir "$package"; then
				_libertine_compile_packageLock_addLockTrapHandler_package="$package"
				return 0
			else
				core_message NOTICE "${_libertine_compile_depth}Waiting 1 second to acquire lock for package '$package'"
				sleep 1
			fi
		done
		
	popd
}

core_dependency_requires '*' rm
_libertine_compile_packageLock_releasePerPackageMutexLock()
{
	# If SIGTERM happens after rm -rf but before assignment of '' to _libertine_compile_packageLock_addLockTrapHandler_package our trap handler runs and potentially deletes another processes' lock
	pushd "$libertine_packageLocksOutputFolderPath"

		rm -rf "$_libertine_compile_packageLock_addLockTrapHandler_package"
		_libertine_compile_packageLock_addLockTrapHandler_package=''
		
	popd
}

_libertine_compile_packageLock_doItWhilstLocked_loadFunctions()
{
	local functionsFilePath="$(libertine_public_originalPackagePath)"/"$package".functions
	
	if [ ! -f "$functionsFilePath" ]; then
		if [ ! -d "$(libertine_public_originalPackagePath)" ]; then
			core_exitError $core_commandLine_exitCode_CONFIG "The package '$package' does not exist (at '$(libertine_public_originalPackagePath)'); required by package '$parentPackage'"
		fi
		
		core_exitError $core_commandLine_exitCode_CONFIG "The package '$package' file '$package.functions', does not exist; required by package '$parentPackage'"
	fi
	. "$functionsFilePath"
	
	if ! core_functions_exists libertine_compile_${package}; then
		core_exitError $core_commandLine_exitCode_CONFIG "The package '$package' has a '$package.functions' that does not contain a function 'libertine_compile_${package}'"
	fi
	
	_libertine_compile_dependOnEverythingBuiltIfLinux
}

core_usesIn libertine env
core_dependency_requires '*' cat rm chmod mkdir sort
libertine_compile_packageLock_doItWhilstLocked()
{
	local package="$1"
	local parentPackage="$2"
	
	# Load $package.functions
	local variant=''
	local copy_subset=''
	local _libertine_compile_depends
	local _libertine_compile_depends_initialised
	core_variable_array_initialise _libertine_compile_depends
	local _libertine_compile_buildBinariesNeeded
	local _libertine_compile_buildBinariesNeeded_initialised
	core_variable_array_initialise _libertine_compile_buildBinariesNeeded
	local _libertine_compile_buildBinariesProvided
	local _libertine_compile_buildBinariesProvided_initialised
	core_variable_array_initialise _libertine_compile_buildBinariesProvided
	_libertine_compile_packageLock_doItWhilstLocked_loadFunctions
	
	# Linux package is special, as it has no real parent, and it depends additionally in the packages in packages.list
	if [ "$package" = 'linux' ]; then
		case "$parentPackage" in
			
			'.machine')
				_libertine_compile_theLinuxPackageAlsoDependsOnPackagesInThePackagesListFile
			;;
			
			*)
				core_exitError 1 "The linux package can not be a dependency of anything (it is a dependency of '$parentPackage')"
			;;
				
		esac
	fi
		
	# Compile dependencies if not already built; has to be done whilst not holding lock
	_libertine_compile_packageLock_releasePerPackageMutexLock
		core_variable_array_iterate _libertine_compile_depends _libertine_compile_buildDependency
	_libertine_compile_packageLock_acquirePerPackageMutexLock "$package"
	
	# Another process might have built this package whilst we weren't holding the lock when we were compiling dependencies; go with it!
	local ourPackageComputedHashResultFilePath="$(_libertine_hash_computedHashResultFilePath "$package")"
	local ourPackageHash="$(cat "$ourPackageComputedHashResultFilePath")"
	local cachedBuiltDependentPackageVariantsFolderPath="$libertine_packageCacheOutputFolderPath"/"$package"
	local cachedBuiltDependentPackageFolderPath="$cachedBuiltDependentPackageVariantsFolderPath"/"$ourPackageHash"
	if [ -f "$cachedBuiltDependentPackageFolderPath"/.built ]; then
		core_message NOTICE "${_libertine_compile_depth}Another process built package '$package'"
		return 0
	else
		core_message NOTICE "${_libertine_compile_depth}Need to build package '$package'"
	fi
	
	core_message NOTICE "${_libertine_compile_depth}Deleting previous build output for package '$package'"
	chmod -R 0777 "$(libertine_public_outputPath)"
	rm -rf "$(libertine_public_outputPath)"
	
	core_message NOTICE "${_libertine_compile_depth}Copying source for package '$package'"
	_libertine_compile_copySourcePath

	core_message NOTICE "${_libertine_compile_depth}Creating input sysroot for package '$package'"
	_libertine_compile_createInputSysroot

	core_message NOTICE "${_libertine_compile_depth}Miscellaneous preparations before building package '$package'"
	mkdir -m 0700 -p "$(libertine_public_outputMiscPath)"
	mkdir -m 0700 -p "$(libertine_public_outputBuildSysrootPath)"
	mkdir -m 0700 -p "$(libertine_public_outputHostSysrootPath)"
	mkdir -m 0700 -p "$(libertine_public_outputInitramfsPath)"
	mkdir -m 0700 -p "$(libertine_public_buildProvidesPath)"
	printf '' >"$(libertine_public_outputInitramfsContentsFilePath)"
	printf '' >"$(libertine_public_outputKernelBootCommandLineFilePath)"
	
	local logFolderPath="$(libertine_public_outputPath)"

	core_message NOTICE "${_libertine_compile_depth}Building package '$package' variant '$variant' (logs in '$logFolderPath')"

	# Change environment variable PATH
	libertine_path_exportPATH
	
		# Changes things like SHELL
		libertine_env_cleanseBeforePackageCompile

		# These functions run under a modified path, eg to make patch use one we built via build_netbsd_src_patch
		_libertine_compile_installMenuConfigIfPresent
		_libertine_compile_sourcePackageConfig
		_libertine_compile_patchIfPresent
		libertine_public_adjustShaBangAllExecutableFilesInPath "$(libertine_public_packagePath)"

		core_message INFO "    ${_libertine_compile_depth}Running package ${package} build function 'libertine_compile_${package}'"
		set -e
		libertine_compile_${package} 1>>"$logFolderPath"/out.log 2>>"$logFolderPath"/err.log
	
		libertine_path_installBuildBinariesProvided

		core_variable_array_appendUniquely _libertine_compile_built "$package"

	# Restore PATH
	export PATH="$libertine_originalPATH"
}

core_usesIn libertine path
libertine_compile_configure()
{
	local packagesListFilePath="$libertine_machineSettingsFolderPath"/packages.list
	if [ ! -s "$packagesListFilePath" ]; then
		core_exitError 1 "packages.list file '$packagesListFilePath' does not exist, is not a readable file or has no contents"
	fi
	
	_libertine_compile_depth=''
	core_variable_array_initialise _libertine_compile_built
	core_variable_array_initialise _libertine_packages
	
	local package
	while IFS='' read -r package
	do
		if [ -z "$package" ]; then
			continue
		fi
		
		case "$package" in
			
			'')
				continue
			;;
			
			'#'*)
				continue
			;;
			
			*)
				if [ ! -d "$libertine_machineInputPackagesPath"/"$package" ]; then
					core_exitError 1 "Package '$package' does not exist in folder '$libertine_machineInputPackagesPath'"
				fi
			
				core_variable_array_appendUniquely _libertine_packages "$package"
			;;
			
		esac
		
	done <"$packagesListFilePath"
}

core_dependency_requires '*' rm cp
libertine_compile()
{
	core_message NOTICE STARTING
	
	
	libertine_compile_buildDependencyIfRequiredAndAddOurselvesToItsListOfReverseDependencies linux '.machine'
	
	
	local kernelOutputFilePath="$libertine_machineOutputFolderPath"/libertine-linux.vmlinuz
	core_message NOTICE "Installing linux kernel to '$kernelOutputFilePath'"
	rm -rf "$kernelOutputFilePath"
	cp "$(libertine_public_outputMiscPath linux)"/vmlinuz "$kernelOutputFilePath"
	
	
	core_message NOTICE FINISHED
}
