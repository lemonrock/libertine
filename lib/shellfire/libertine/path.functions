# This file is part of libertine. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT. No part of libertine, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright © 2016 The developers of libertine. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT.


libertine_path_installBuildBinariesProvided()
{
	libertine_path_installBuildBinariesProvided_callback()
	{
		local binary="$core_variable_array_element"
		
		local relativeBinaryPath=../build-sysroot/usr/bin/"$binary"
				
		if [ ! -x "$relativeBinaryPath" ]; then
			core_exitError $core_commandLine_exitCode_UNAVAILABLE "Provided build binary (assumed to be in usr/bin) '$binary' is not executable at '$(pwd)/$relativeBinaryPath' for package '$package'"
		fi
		
		ln -s "$relativeBinaryPath" "$binary"
	}
	
	pushd "$(libertine_public_buildProvidesPath)"
	
		core_variable_array_iterate _libertine_compile_buildBinariesProvided libertine_path_installBuildBinariesProvided_callback
		
	popd
}

libertine_path_fakeUname_forBuild()
{
	local shellFilePath="$1"
	local binFilePath="$2"
	
	_libertine_path_fakeUname "$shellFilePath" "$binFilePath" "$libertine_buildUnameArchitecture" "$libertine_buildUnameOperatingSystem" "$libertine_buildUnameTimestamp"
}

libertine_path_fakeUname_forHost()
{
	local shellFilePath="$1"
	local binFilePath="$2"
	
	_libertine_path_fakeUname "$shellFilePath" "$binFilePath" "$libertine_hostUnameArchitecture" "$libertine_hostUnameOperatingSystem" "$libertine_hostUnameTimestamp"
}

core_dependency_requires '*' cat chmod sh
_libertine_path_fakeUname()
{
	local shellFilePath="$1"
	local binFilePath="$2"
	local architecture="$3"
	local operatingSystem="$4"
	local timestamp="$5"
	
	local kernelName="$operatingSystem"
	local osName="$operatingSystem"
	
	# This, obviously, won't match the actual version of linux we are building. However, it does encode (a) it's modern and (b) it's grsecurity enabled
	# If necessary, over time, we can adjust this slightly. It is possible to extract the version of linux we're building (see packages/linux/linux-patches/apply-patches, function apply_patches_findLinuxVersion)
	# However, for that to be accurate, it would have to be extracted to its own little script and run only after linux has been patched. Quite complex.
	# We are only faking uname for the small number of tools (eg git, I'm looking at you) that use it to work out how to change settings even when cross-compiling...
	local kernelVersion='4.4.35-0-grsec'
	
	{
		cat <<EOF
#!${shellFilePath}
# This file is part of libertine. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT. No part of libertine, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright © 2016 The developers of libertine. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT.


set -e
set -u
set -f

architecture='${architecture}'
kernelName='${kernelName}'
osName='${osName}'
kernelVersion='#1-Libertine SMP ${timestamp}'
kernelRelease='${kernelVersion}'

EOF
		cat <<'EOF'
uname_main()
{
	local hostName='libertine'
	local processorType='unknown'
	local hardwarePlatform='unknown'

	if [ $# -eq 0 ]; then
		printf '%s\n' "$kernelName"
		return 0
	fi

	while [ $# -ne 0 ]
	do
		case "$1" in

			-a)
				printf '%s %s %s %s %s %s\n' "$kernelName" "$hostName" "$kernelRelease" "$kernelVersion" "$architecture" "$osName"
			;;

			-m)
				printf '%s\n' "$architecture"
			;;

			-n)
				printf '%s\n' "$hostName"
			;;

			-r)
				printf '%s\n' "$kernelRelease"
			;;

			-s)
				printf '%s\n' "$kernelName"
			;;

			-p)
				printf '%s\n' "$processorType"
			;;

			-v)
				printf '%s\n' "$kernelVersion"
			;;

			-i)
				printf '%s\n' "$hardwarePlatform"
			;;

			-o)
				printf '%s\n' "$osName"
			;;
			
			*)
				# Will printf '-x' but should actually print 'x' for %s
				printf 'uname: unrecognized option: %s\n' "$1" 1>&2
				exit 1
			;;

		esac
		
		shift 1
	done
}

uname_main "$@"
EOF
	} >"$binFilePath"
	
	chmod +x "$binFilePath"
}

_libertine_path_systemEssentials()
{
	local callback="$1"
	shift 1
	
	local alreadyHandledProgramNames
	local alreadyHandledProgramNames_initialised
	core_variable_array_initialise alreadyHandledProgramNames
	
	local packageManager
	local programName
	local alreadyInstalledProgramName
	local originalIFS="$IFS"
	local IFS=' '
	while IFS=' ' read -r packageManager programName
	do
		IFS="$originalIFS"
		case "$packageManager" in
			
			'*'|"$core_dependency_packageManager")
				packageManager="$core_dependency_packageManager"
				if core_variable_array_contains alreadyHandledProgramNames "$programName"; then
					continue
				fi
				core_variable_array_append alreadyHandledProgramNames "$programName"
				${callback} "$programName" "$@"
			;;

			# Because of the heredoc, there's an extra blank line. A messy alternative is https://unix.stackexchange.com/questions/102891/posix-compliant-way-to-work-with-a-list-of-filenames-possibly-with-whitespace
			'')
				break
			;;
			
			*)
				continue
			;;
			
		esac
	done <<-EOF
		${_core_dependency_requires}
	EOF
	IFS="$originalIFS"
}

core_dependency_requires '*' mkdir ln
libertine_path_exportPATH()
{
	local ourPATH="$(libertine_public_buildNeedsPath)"
	mkdir -m 0755 -p "$ourPATH"
	
	# Add essential binaries
	core_variable_array_appendUniquely _libertine_compile_buildBinariesNeeded env sh
	
	# Add essential binaries to execute functions in public.functions, etc
	_libertine_path_exportPATH_callback()
	{
		local binary="$1"
		
		# Except don't add binaries that really aren't required (sudo, package managers, kill)
		case "$binary" in
		
			sudo)
				return 0
			;;
		
			apk|apt-get|rpm|urpmi|pkg|pkgin|pkg_add|emerge)
				return 0
			;;
			
			# stat awk grep  needed outside of compile
			
			# Miscellaneous code brought in by shellfire that is almost certainly not needed ordinarily
			kill)
				return 0
			;;
		
		esac
		
		core_variable_array_appendUniquely _libertine_compile_buildBinariesNeeded "$binary"
	}
	_libertine_path_systemEssentials _libertine_path_exportPATH_callback
	
	libertine_path_exportPATH_addSymlinksToPath()
	{
		local binary="$core_variable_array_element"
		
		local baseInfoMessage="    ${_libertine_compile_depth}Package '$package' needs binary '$binary' to build"
		
		if [ "$binary" = 'uname' ]; then
			core_message INFO "$baseInfoMessage (faked for build)"
			libertine_path_fakeUname_forBuild "$ourPATH"/sh "$ourPATH"/fake-uname-build
			ln -s fake-uname-build "$ourPATH"/uname
			return 0
		fi
		
		libertine_path_exportPATH_addSymlinksToPath_findBuildProvidedBinaries()
		{
			# Iterates over packages already build in reverse order (ie most recent first)
			local count=$#
			local index=$count
			while [ $index -ne 0 ]
			do
				eval local alreadyBuiltPackageInReverseOrder="\${$index}"
				
				local relativePath="$(libertine_public_buildProvidesPathRelativeToCurrentPackagePATH "$alreadyBuiltPackageInReverseOrder")"/"$binary"
				if [ -x "$ourPATH"/"$relativePath" ]; then
					pushd "$ourPATH"
						core_message INFO "$baseInfoMessage (from package '$alreadyBuiltPackageInReverseOrder')"
						ln -s "$relativePath" "$binary"
					popd
					
					return 0
				fi
								
				index=$((index-1))
			done
			
			# Not provided by any package, search on default PATH
			if command -v "$binary" 1>/dev/null 2>/dev/null; then
				pushd "$ourPATH"
					local hostPath="$(command -v "$binary")"
					core_message INFO "$baseInfoMessage (from host PATH at '$hostPath')"
					ln -s "$hostPath" "$binary"
				popd
			else
				core_exitError $core_commandLine_exitCode_OSFILE "Could not find a package that provides, or in the default PATH, the binary '$binary' needed to build the package '$package' in PATH '$PATH'"
			fi
		}
		
		# Iterates over packages already build in reverse order (ie most recent first)
		core_variable_array_passToFunctionAsArguments _libertine_compile_built libertine_path_exportPATH_addSymlinksToPath_findBuildProvidedBinaries
	}
	
	# Adds each needed binary into a PATH
	core_variable_array_iterate _libertine_compile_buildBinariesNeeded libertine_path_exportPATH_addSymlinksToPath
	
	export PATH="$ourPATH"
}
