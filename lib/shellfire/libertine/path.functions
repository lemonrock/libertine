# This file is part of libertine. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT. No part of libertine, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright © 2016 The developers of libertine. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT.


libertine_path_installBuildBinariesProvided()
{
	libertine_path_installBuildBinariesProvided_callback()
	{
		local binary="$core_variable_array_element"
		
		local relativeBinaryPath=../build-sysroot/usr/bin/"$binary"
				
		if [ ! -x "$relativeBinaryPath" ]; then
			core_exitError $core_commandLine_exitCode_UNAVAILABLE "Provided build binary (assumed to be in usr/bin) '$binary' is not executable at '$(pwd)/$relativeBinaryPath' for package '$package'"
		fi
		
		ln -s "$relativeBinaryPath" "$binary"
	}
	
	pushd "$(libertine_public_buildProvidesPath)"
	
		core_variable_array_iterate _libertine_compile_buildBinariesProvided libertine_path_installBuildBinariesProvided_callback
		
	popd
}

core_dependency_requires '*' cat chmod sh
_libertine_path_fakeUname()
{
	local binFolderPath="$1"
	
	local filePath="$binFolderPath"/uname
	
	{
		printf '#!%s\n' "$binFolderPath"/sh
		cat <<'EOF'
# This file is part of libertine. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT. No part of libertine, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright © 2016 The developers of libertine. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/libertine-linux/libertine/master/COPYRIGHT.

set -e
set -u
set -f

uname_main()
{
	local architecture='x86_64'
	local hostName='libertine'
	local kernelRelease='4.4.35-0-grsec'
	local kernelName='Linux'
	local processorType='unknown'
	local kernelVersion='#1-Libertine SMP Thu Jun 16 09:22:17 UTC 2016'
	local hardwarePlatform='unknown'
	local osName='Linux'

	if [ $# -eq 0 ]; then
		printf '%s\n' "$kernelName"
		return 0
	fi

	while [ $# -ne 0 ]
	do
		case "$1" in

			-a)
				printf '%s %s %s %s %s %s\n' "$kernelName" "$hostName" "$kernelRelease" "$kernelVersion" "$architecture" "$osName"
			;;

			-m)
				printf '%s\n' "$architecture"
			;;

			-n)
				printf '%s\n' "$hostName"
			;;

			-r)
				printf '%s\n' "$kernelRelease"
			;;

			-s)
				printf '%s\n' "$kernelName"
			;;

			-p)
				printf '%s\n' "$processorType"
			;;

			-v)
				printf '%s\n' "$kernelVersion"
			;;

			-i)
				printf '%s\n' "$hardwarePlatform"
			;;

			-o)
				printf '%s\n' "$osName"
			;;
			
			*)
				# Will printf '-x' but should actually print 'x' for %s
				printf 'uname: unrecognized option: %s\n' "$1" 1>&2
				exit 1
			;;

		esac
		
		shift 1
	done
}

uname_main "$@"
EOF
	} >"$filePath"
	
	chmod +x "$filePath"
}

_libertine_path_systemEssentials()
{
	local callback="$1"
	shift 1
	
	local alreadyHandledProgramNames
	local alreadyHandledProgramNames_initialised
	core_variable_array_initialise alreadyHandledProgramNames
	
	local packageManager
	local programName
	local alreadyInstalledProgramName
	local originalIFS="$IFS"
	local IFS=' '
	while IFS=' ' read -r packageManager programName
	do
		IFS="$originalIFS"
		case "$packageManager" in
			
			'*'|"$core_dependency_packageManager")
				packageManager="$core_dependency_packageManager"
				if core_variable_array_contains alreadyHandledProgramNames "$programName"; then
					continue
				fi
				core_variable_array_append alreadyHandledProgramNames "$programName"
				${callback} "$programName" "$@"
			;;

			# Because of the heredoc, there's an extra blank line. A messy alternative is https://unix.stackexchange.com/questions/102891/posix-compliant-way-to-work-with-a-list-of-filenames-possibly-with-whitespace
			'')
				break
			;;
			
			*)
				continue
			;;
			
		esac
	done <<-EOF
		${_core_dependency_requires}
	EOF
	IFS="$originalIFS"
}

core_dependency_requires '*' mkdir ln
libertine_path_exportPATH()
{
	local ourPATH="$(libertine_public_buildNeedsPath)"
	mkdir -m 0755 -p "$ourPATH"
	
	# Add essential binaries
	core_variable_array_appendUniquely _libertine_compile_buildBinariesNeeded env sh
	
	# Add essential binaries to execute functions in public.functions, etc
	_libertine_path_exportPATH_callback()
	{
		local binary="$1"
		
		# Except don't add binaries that really aren't required (sudo, package managers, kill)
		case "$binary" in
		
			sudo)
				return 0
			;;
		
			apk|apt-get|rpm|urpmi|pkg|pkgin|pkg_add|emerge)
				return 0
			;;
			
			# stat awk grep  needed outside of compile
			
			# Miscellaneous code brought in by shellfire that is almost certainly not needed ordinarily
			kill)
				return 0
			;;
		
		esac
		
		core_variable_array_appendUniquely _libertine_compile_buildBinariesNeeded "$binary"
	}
	_libertine_path_systemEssentials _libertine_path_exportPATH_callback
	
	libertine_path_exportPATH_addSymlinksToPath()
	{
		local binary="$core_variable_array_element"
		
		local baseInfoMessage="    ${_libertine_compile_depth}Package '$package' needs binary '$binary' to build"
		
		if [ "$binary" = 'uname' ]; then
			core_message INFO "$baseInfoMessage (faked)"
			_libertine_path_fakeUname "$ourPATH"
			return 0
		fi
		
		libertine_path_exportPATH_addSymlinksToPath_findBuildProvidedBinaries()
		{
			# Iterates over packages already build in reverse order (ie most recent first)
			local count=$#
			local index=$count
			while [ $index -ne 0 ]
			do
				eval local alreadyBuiltPackageInReverseOrder="\${$index}"
				
				local relativePath="$(libertine_public_buildProvidesPathRelativeToCurrentPackagePATH "$alreadyBuiltPackageInReverseOrder")"/"$binary"
				if [ -x "$ourPATH"/"$relativePath" ]; then
					pushd "$ourPATH"
						core_message INFO "$baseInfoMessage (from package '$alreadyBuiltPackageInReverseOrder')"
						ln -s "$relativePath" "$binary"
					popd
					
					return 0
				fi
								
				index=$((index-1))
			done
			
			# Not provided by any package, search on default PATH
			if command -v "$binary" 1>/dev/null 2>/dev/null; then
				pushd "$ourPATH"
					local hostPath="$(command -v "$binary")"
					core_message INFO "$baseInfoMessage (from host PATH at '$hostPath')"
					ln -s "$hostPath" "$binary"
				popd
			else
				core_exitError $core_commandLine_exitCode_OSFILE "Could not find a package that provides, or in the default PATH, the binary '$binary' needed to build the package '$package' in PATH '$PATH'"
			fi
		}
		
		# Iterates over packages already build in reverse order (ie most recent first)
		core_variable_array_passToFunctionAsArguments _libertine_compile_built libertine_path_exportPATH_addSymlinksToPath_findBuildProvidedBinaries
	}
	
	# Adds each needed binary into a PATH
	core_variable_array_iterate _libertine_compile_buildBinariesNeeded libertine_path_exportPATH_addSymlinksToPath
	
	export PATH="$ourPATH"
}
